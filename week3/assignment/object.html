
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>exam</title>
<link rel="stylesheet" href="common.css" />
<script src="http://code.jquery.com/jquery-latest.js"></script>
<script src="../../js/jquery-1.12.4.min.js" type="text/javascript"></script>
<style>
	strong {background-color: yellow;}
	pre {background-color: #000; font-weight:bold; color:#fff;}
</style>
<script>

	$(function(){
		//내 소스
		// var obj1 = {
		// 	e: 'e',
		// 	d: 'd',
		// 	b: 'b',
		// 	g: 'g',
		// 	c: 'c',
		// 	f: 'f',
		// 	a: 'a'
		// };
		// var arr = [];
		// for (var key in obj1){
		// 	arr.push(key);
		// }
		// arr.sort();
		// var res = arr.join('');
		// console.log(res);

		// var num = 33;
		// var obj = {
		// 	num1 : 1,
		// 	init: function () {
		// 		console.log(this);
		// 	}
		// };
		// obj.init();
		var exam1 = {
			obj: ['e','d','b','g','c','f','a'],

			init: function(){
				this.bindEvent();
			},

			bindEvent: function(){
				console.log(this.obj.sort().join(''));
			}
		}


		//bcaebe -> {a : 1, b : 2, c : 1, e : 2}
		var exam2 = {
			str: 'bcaebe',

			init: function(){
				this.obj = {},
				this.objStr = this.str.split('').sort();
				console.log(this.objStr);
				this.bindEvent();
			},

			bindEvent: function(){
				for(var i=0; i<this.objStr.length; i++){
					if(this.obj.hasOwnProperty(this.objStr[i])){
						//console.log('objStr =>' + this.obj[this.objStr[i]]);
						this.obj[this.objStr[i]] = this.obj[this.objStr[i]] + 1;
						//console.log(i + ' :' + this.obj[this.objStr[i]]);
					}else{
						this.obj[this.objStr[i]] = 1;
					}
				}
				console.log(this.obj);
			}
		}
		exam1.init();
		exam2.init();
	});

	
	// window.onload = function(){


	// 	//bcaebe -> {a : 1, b : 2, c : 1, e : 2}

	// 	var obj_str = {
	// 		str: 'bcaebe'
	// 	};

	// 	for(var s in obj_str){
	// 		var arr=[];
	// 		//Object.prototype.hasOwnProperty.call(obj_str, s)
	// 		//obj_str.hasOwnProperty(s)
	// 		if(Object.prototype.hasOwnProperty.call(obj_str, s)){
				
	// 			arr = obj_str[s].split('');
	// 			console.log(arr);

	// 			var cnt = 0;

	// 			for(var i=0; i<arr.length; i++){

	// 				for(var j=i+1; j<arr.length; j++){
	// 					if(arr[i] == arr[j]) {
	// 						cnt++;
	// 						var key_name = '' +arr[i];
	// 						var obj_new = new Object();
	// 						obj_new.a = cnt;
	// 					}
	// 				}
	// 			}
				

	// 		}else{
	// 			console.log('nothas');
	// 		}
	// 	}
	// }
	
</script>
</head>
<body>
<!-- wrapper [s] -->
<div id="wrapper">
	<!-- header [s] -->
	<div id="header">
	</div>
	<!-- header [e] -->
	<hr />
	<!-- container [s] -->
	<div id="container">
		<div class="exam_wrap">
			<h1>Q. 함수 호출시 new 를 붙인 것과 안 붙인 것의 차이를 설명하세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = function () {<br>
			&nbsp;&nbsp;&nbsp;console.log(this);<br>
			};<br>
			obj();<br>
			// new obj();
			</div>
			<div>
				<strong> ## 함수 호출시 new 를 붙인 것과 안 붙인 것의 차이 </strong>
				<p>
					함수 호출시 기존 함수에 new 연산자를 붙여서 호출하면 <strong>생성자 함수</strong>로 동작합니다.<br>
					생성자 함수 호출 동작 방식은..<br>
					<strong> 1) 빈 객체 생성 및 this 바인딩 </strong> <br>
					- 생성자 함수가 실행되기 전, 빈 객체가 생성됩니다. <br>
					- 그리고 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다.</br>
					<strong> 2) this를 통한 프로퍼티를 생성 </strong> <br>
					<strong> 3) 생성된 객체 반환 </strong> <br>
				</p>
				<div>
					<img src="imgs/console.png" alt="함수 호출(NEW를 붙인 것과 안 붙인 것)">
					<p>[출처] http://poiemaweb.com/js-this</p>
				</div>

				<strong>결론: *this의 바인딩이 다르게 됩니다.</strong>
				<strong>obj() 함수로 호출했을 경우, this는 전역객체(window)에 바인딩 되고,</strong><br>
				<strong>new Obj() new를 붙여서 함수를 호출할 경우, 객체 인스턴스를 생성하는 생성자 함수로 동작하고 생성자 함수가 암묵적으로 생성한 빈객체에(new obj()가 실행되기 전에) this가 바인딩 됩니다.</strong><br>

			</div>
		</div>
		<div class="exam_wrap">
			<h1>Q. 객체 내에서의 this 를 설명하세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = {<br>
			&nbsp;&nbsp;&nbsp;init : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this);<br>
			&nbsp;&nbsp;&nbsp;}<br>
			};<br>
			obj.init();<br>
			</div>
			<div>
				<p>
					함수가 객체의 프로퍼티이면 메소드 호출 패턴으로 호출됩니다.<br>
					객체 내의 함수를 메소드라고 하고, <br>
					<strong>이 메소드 내부의 this는 해당 메소드를 호출한 객체에 바인딩됩니다.</strong>
					<strong>예시에서 this는 init함수를 호출한 obj객체에 바인딩되므로, console.log(this);의 결과는 obj가 됩니다.</strong>
				</p>

				<div>
					<div>++ 참고) 프로토타입 객체 내부의 메소드에서 사용된 this도 해당 메소드를 호출한 객체에 바인딩 됩니다.</div>
					<img src="imgs/console2.png" alt="프로토타입 객체의 this">
					<div>[출처] http://poiemaweb.com/js-this</div>
				</div>
			</div>
		</div>
		<div class="exam_wrap">
			<h1>Q. 객체 내의 다른 메서드를 호출해보세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = {<br>
			&nbsp;&nbsp;&nbsp;init : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setElements 함수를 호출해봐요~<br>
			<strong>this.setElements();</strong>
			&nbsp;&nbsp;&nbsp;},<br>
			&nbsp;&nbsp;&nbsp;setElements : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('call');<br>
			&nbsp;&nbsp;&nbsp;}<br>
			};<br>
			obj.init();<br>
			</div>
		</div>
		<div class="exam_wrap">
			<h1>Q. 객체 내에서 다른 객체의 메서드를 호출해보세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = {<br>
			&nbsp;&nbsp;&nbsp;init : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 객체 obj2 의 init 을 호출해봐요~<br>
			&nbsp;&nbsp;&nbsp;}<br>
			};<br>
			var obj2 = {<br>
			&nbsp;&nbsp;&nbsp;init : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('call');<br>
			&nbsp;&nbsp;&nbsp;}<br>
			};<br>
			obj.init();<br>
			<strong>obj2.init();</strong>
			</div>
		</div>
		<div class="exam_wrap">
			<h1>Q. 데이터 타입들을 모두 넣은후, 값들을 출력해보세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = {<br>
			&nbsp;&nbsp;&nbsp;func : function () {<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('func');<br>
			&nbsp;&nbsp;&nbsp;},<br>
			&nbsp;&nbsp;&nbsp;num : 3,<br>
			<strong>name: 'ChoiMinKyung',</strong><br>
			<strong>arr : ['age', 'name', 'tel'],</strong><br>
			<strong>checkEvent : function(){ alert('function test');}</strong><br>			
			};<br>
			console.log(obj.func);<br>
			console.log(obj.num);<br>
			<strong>console.log(obj.name);</strong><br>
			<strong>console.log(obj.arr);</strong><br>
			<strong>console.log(obj.checkEvent);</strong><br>
			</div>
		</div>
		<div class="exam_wrap">
			<h1>Q. 객체내의 모든 속성들의 값을 배열에 저장한후, abc 순으로 sorting 하여, 'abcdefg' 문자열로 출력해보세요.</h1>
			<div class="exam_q">예시)<br>
			var obj = {<br>
			&nbsp;&nbsp;&nbsp;e : 'e',<br>
			&nbsp;&nbsp;&nbsp;d : 'd',<br>
			&nbsp;&nbsp;&nbsp;b : 'b',<br>
			&nbsp;&nbsp;&nbsp;g : 'g',<br>
			&nbsp;&nbsp;&nbsp;c : 'c',<br>
			&nbsp;&nbsp;&nbsp;f : 'f',<br>
			&nbsp;&nbsp;&nbsp;a : 'a'<br>
			};<br>
			</div>
	<pre><code>

	var obj = {
		e: 'e',
		d: 'd',
		b: 'b',
		g: 'g',
		c: 'c',
		f: 'f',
		a: 'a'
	};
	var arr = [];
	for (var key in obj){
		arr.push(key);
	}
	arr.sort();
	var res = arr.join('');
	console.log(res);

	-----------------------------------------------

	var exam1 = {
		obj: ['e','d','b','g','c','f','a'],

		init: function(){
			this.bindEvent();
		},

		bindEvent: function(){
			console.log(this.obj.sort().join(''));
		}
	}

	exam1.init();
	</code></pre>
		</div>
		<div class="exam_wrap">
			<h1>Q. 'bcaebe' 문자열을 hasOwnProperty 를 사용해서, {a : 1, b : 2, c : 1, e : 2} 로 변경해보세요.</h1>
		</div>
	<pre><code>
	var exam2 = {
		str: 'bcaebe',

		init: function(){
			this.obj = {},
			this.objStr = this.str.split('').sort();
			console.log(this.objStr);
			this.bindEvent();
		},

		bindEvent: function(){
			for(var i=0; i < this.objStr.length; i++){
				if(this.obj.hasOwnProperty(this.objStr[i])){			
					this.obj[this.objStr[i]] = this.obj[this.objStr[i]] + 1;
				}else{
					this.obj[this.objStr[i]] = 1;
				}
			}
			console.log(this.obj);
		}
	}

	exam2.init();
	</code></pre>
	</div>
	<!-- container [e] -->
	<hr />
	<!-- footer [s] -->
	<div id="footer">
	</div>
	<!-- footer [e] -->
</div>
<!-- wrapper [e] -->
</body>
</html>
